// Generated by server.go.tmpl
package service

import (
	"context"
	"fmt"
	"script_validation/models"

	"github.com/sashabaranov/go-openai"
)

func (s *Service) GetProvider(id string) (*models.Provider, error) {
	provider := &models.Provider{BaseModel: models.BaseModel{ID: id}}
	tx := s.Db.First(provider)
	if tx.Error != nil {
		return nil, tx.Error
	}
	return provider, nil
}

func (s *Service) CreateProvider(input models.ProviderCreate) (*models.Provider, error) {
	// Create the encryption key
	aesKey, err := loadOrCreateAESKey(".env")
	if err != nil {
		return nil, err
	}
	encryptedApiKey, err := Encrypt(input.ApiKey, aesKey)
	if err != nil {
		return nil, err
	}

	// Create the provider
	provider := &models.Provider{
		BaseModel:       models.BaseModel{ID: input.Id},
		BaseUrl:         input.BaseUrl,
		Type:            input.Type,
		EncryptedAPIKey: encryptedApiKey,
		Requests:        input.Requests,
		Interval:        input.Interval,
		Unit:            input.Unit,
		ValidKey:        false,
	}

	// Initialize the provider
	client := openai.NewClient(input.ApiKey, provider.BaseUrl)

	s.llmProviders[provider.ID] = &llmProvider{
		Provider: provider,
		client:   client,
	}

	// Load any models that are compatible with the provider
	_, err = s.PullLLMsFromProvider(provider.ID)
	if err == nil {
		provider.ValidKey = true
	}

	tx := s.Db.Create(provider)
	if tx.Error != nil {
		return nil, tx.Error
	}

	//Initalizes the rate limiter
	s.limiter.GetLimiter(provider)

	return provider, nil
}

func (s *Service) GetAllProviders() ([]*models.Provider, error) {
	providers := []*models.Provider{}
	tx := s.Db.Find(&providers)
	if tx.Error != nil {
		return nil, tx.Error
	}
	return providers, nil
}

func (s *Service) UpdateProvider(id string, input models.ProviderUpdate) (*models.Provider, error) {
	provider := &models.Provider{BaseModel: models.BaseModel{ID: id}}
	tx := s.Db.First(provider)
	if tx.Error != nil {
		return nil, tx.Error
	}
	// Apply the updates to the model
	if input.ApiKey != "" {
		// Create the encryption key
		aesKey, err := loadOrCreateAESKey(".env")
		if err != nil {
			return nil, err
		}
		encryptedApiKey, err := Encrypt(input.ApiKey, aesKey)
		if err != nil {
			return nil, err
		}
		provider.EncryptedAPIKey = encryptedApiKey
		// Make the update to the client
		s.llmProviders[provider.ID] = &llmProvider{
			Provider: provider,
			client:   openai.NewClient(input.ApiKey, provider.BaseUrl),
		}
	}

	if input.BaseUrl != "" {
		provider.BaseUrl = input.BaseUrl
	}

	if input.Type != "" {
		provider.Type = input.Type
	}

	if input.Requests != 0 {
		provider.Requests = input.Requests
	}

	if input.Interval != 0 {
		provider.Interval = input.Interval
	}

	if input.Unit != "" {
		provider.Unit = input.Unit
	}

	// Test the provider by tyring to list the models
	_, err := s.llmProviders[provider.ID].client.ListModels(context.Background())
	if err != nil {
		provider.ValidKey = false
		fmt.Println("Error: ", err)
	} else {
		provider.ValidKey = true

	}

	tx = s.Db.Save(provider)
	if tx.Error != nil {
		return nil, tx.Error
	}

	return provider, nil
}

func (s *Service) DeleteProvider(id string) (*models.Provider, error) {
	provider := &models.Provider{BaseModel: models.BaseModel{ID: id}}

	tx := s.Db.First(provider)
	if tx.Error != nil {
		return nil, tx.Error
	}
	tx = s.Db.Delete(provider)
	if tx.Error != nil {
		return nil, tx.Error
	}
	return nil, nil
}

type ProviderManager interface {
	GetProvider(id string) (*models.Provider, error)
	CreateProvider(*models.ProviderCreate) (*models.Provider, error)
	GetAllProviders() ([]*models.Provider, error)
	UpdateProvider(id string, input models.ProviderUpdate) (*models.Provider, error)
	DeleteProvider(id string) (any, error)
}
